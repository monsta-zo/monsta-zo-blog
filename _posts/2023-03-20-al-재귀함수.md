---
layout: single
title: "[알고리즘] 재귀 함수"
categories: Algorithm
tag: [Algorithm, CS]
toc: true
toc_sticky: true
author_profile: false
sidebar:
 nav: "docs"

---

# 재귀 함수

**재귀 함수란?**

- 재귀 함수는 자기 자신을 호출하는 함수를 말한다.
  
  - 자기 자신을 호출하는 것을 재귀 호출(Recursion call)이라고 한다.

- 함수 호출은 Call stack에 쌓이기 때문에 스택 자료구조와 유사하게 동작한다.

- 함수형 프로그래밍에선 루프 구현을 재귀로 구현하는 경우가 많다.

- 잘못 작성하면 무한 루프에 빠질 수 있다.

**자바스크립트에서 재귀 함수**

- 콜 스택에 제한이 있다.
  
  - 자바스크립트 엔진마다 제한 수는 다르다.
  
  - 따라서 브라우저마다 다르지만 크롬의 경우 약 1만개 이다.

- 꼬리 재귀(Tail recursion)가 제공되지 않는다 -> 성능 개선을 위한 기능

- 성능이 좋지 않다.

<mark>**<u>하지만, 재귀로 작성하면 쉽게 풀리는 코딩 테스트 문제가 있다!</u>**</mark> (더 효율적인 것은 아님)

## 1. 재귀로 구현해야 편한 알고리즘

- Union-Find

- DFS

- Backtracking

- 불편함을 무시한다면 더 빠른 성능으로(JS에서) 작성할 수 있지만 코딩 테스트는 빨리 푸는 것이 중요하기에 추천하지는 않는다.

## 2. 예시 코드

```js
// 재귀 호출
function recursion(a){
  if(a>10){
    // 무한 루프 방지를 위해
    // 탈출 코드를 작성해야 한다.
    return a;
  }

  return recursion(a+1);
}

console.log(recursion(5)); // 11 
```

## 3. 예제

**피보나치 수열**

앞 두 항의 합이 뒤 항의 값이 되는 수열

![image](https://user-images.githubusercontent.com/83194164/226341117-9fd30084-a818-4487-8a32-e8172e462131.png)

```js
// 피보나치 수열
// 1 1 2 3 5 8 13 
function fibonacci(x){
  if(x<=2){
    return 1;
  }
  return fibonacci(x-1)+fibonacci(x-2);
}
```

**변수 없는 합병 정렬 구현**

![image](https://user-images.githubusercontent.com/83194164/226341631-bb9e5e93-afcc-45ac-bde0-8d43560f1402.png)

```js
//// 합병 정렬
// 결합
const merge = (a,b) => {
  if(a.length===0) return b;
  else if(b.length===0) return a;
  else if(a[0]<b[0]) return [a[0], ...merge(a.slice(1),b)];
  else return [b[0], ...merge(a,b.slice(1))];
}

// 분해
const mergesort = (arr) => {
  if(arr.length < 2) return arr;
  else{
    const mid = Math.floor(arr.length/2);
    return merge(mergesort(arr.slice(0,mid)),mergesort(arr.slice(mid)));
  }
}
```
