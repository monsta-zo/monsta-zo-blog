---
layout: single
title: "[카테캠-기초교육] Part1: Ch1.React 맛보기"
categories: KakaoTechCam
tag: [KakaoTechCam]
toc: true
toc_sticky: true
author_profile: false
sidebar:
 nav: "docs"
header:
 teaser: /assets/images/ktc2.png

---

**모든 강의내용, 자료의 출처는 <u>'카카오 테크 캠퍼스 1기'</u>, <u>'패스트 캠퍼스'</u> 임을 밝힙니다.**

< Part1. React 기초 >

## 02. DOM 다루기 Element 생성하기

*DOM(Document Object Model)*

메모리에 웹 페이지 문서 구조를 표현함으로써 스크립트 및 프로그래밍 언어와 페이지를 연결한다. DOM은 문서를 논리 트리로 표현한다.

*CDN으로 리액트 사용하기*

```html
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
```

각각, React와 ReactDOM을 CDN을 통해 사용할 수 있다.

*`React.createElement()` / `ReactDOM.render()`*

`React.createElement()` 를 통해 요소를 생성할 수 있으며, `ReactDOM.render()` 를 통해 요소를 문서에 렌더링할 수 있다.

```html
<div id="root"></div>
<script>
const rootElement = document.getElementById("root");

// 요소 생성하기
// const element = document.createElement("h1");
// element.textContent = "Hello, world!";
const element = React.createElement("h1", { children: "Hello, world!" });

// 요소 렌더링 하기
// rootElement.appendChild(element);
ReactDOM.render(element, rootElement);
</script>
```

## 03. JSX와 Babel, JSX 다루기

*JSX*

```jsx
const element = <h1>Hello, wrold!</h1>;
```

문자도 HTML도 아닌 JavaScript의 확장 문법. HTML태그 그대로 자바스크립트에서 쓸 수 있게 해준다.

*Babel*

JavaScript 컴파일러이다. JSX 문법을 자바스크립트 언어로 해석해주는 역할을 하며, Babel이 있어야지 JSX 문법을 사용할 수 있다. 

아래의 CDN을 통해 사용할 수 있으며, `<script type="text/babel>` 로 스크립트 문서를 작성해야지 Babel이 정상적으로 해석할 수 있다.

```html
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
...
</script>
```

*JSX와 변수를 통해 요소 만들기*

JSX 문법을 사용하면 변수를 통해 요소를 더 편하게 생성할 수 있다.

```jsx
const rootElement = document.getElementById("root");

const text = "Hello, world!";
const titleClassName = "title123";
const customH1 = <h1 className={titleClassName}>{text}</h1>;
const element = customH1;
ReactDOM.render(element, rootElement);
```

*spread, props를 통해 요소 만들기*

아니면 아래와 같이, spread 연산자와 proprs 객체를 통해서도 만들 수 있다.

```jsx
const rootElement = document.getElementById("root");

const text = "Hello, world!";
const titleClassName = "title123";
const props = { className: titleClassName, children: text };
const customH1 = <h1 {...props} />;
const element = customH1;
ReactDOM.render(element, rootElement);
```

## 04. 멀티 Element 생성하기

앞에서, React와 JSX를 이용하여 요소 하나를 만드는 다양한 방법을 알아봤다. 그럼 요소 여러개를 한번에 만들고 싶을 땐 어떻게 해야할까? 

```html
<div id="root">
      <h1>Hi</h1>
      <h3>Bye</h3>
      <h5>Children</h5>
</div>
```

우리는 이러한 구조를 만들고 싶다. 단계별로 알아보자

*1.JSX + `React.createElement`*

JSX를 통해 여러 요소를 담을 박스를 만들고 안에 `React.createElement()` 를 통해 여러 요소를 만들어 보자. 이때, `children` 속성에 배열을 통해 여러 요소를 넣을 수 있다.

```jsx
const rootElement = document.getElementById("root");
const element = (
    <div
        className="box"
        children = {[
            React.createElement("h1", null, "Hi"),
            React.createElement("h3", null, "Bye"),
            React.createElement("h5", null, "Children")
        ]}
    />
);

ReactDom.render(element, rootElement);
```

하지만 위와같이 작성하면 'div'안에 'box 라는 div'가 들어간 구조가 된다. 따라서 우린 빈 태그를 사용해야하고 `React.Fragment`를 사용할 수 있다.  

2.`React.Fragment` + JSX

`React.Fragment`를 이용해서 빈 태그안에 자식요소들을 넣을 것이다. 그리고 자식 요소들을 `children` 속성에 넣는 것이 아닌 JSX 문법을 통해서 바로 생성해보자.

```js
const rootElement = document.getElementById("root");
const element = (
    <React.Fragment>
      <h1>Hi</h1>
      <h3>Bye</h3>
      <h5>Children</h5>
    </React.Fragment>
);

ReactDom.render(element, rootElement);
```

코드가 훨씬 간결해졌다. 그리고 React에서는 `React.Fragment` 태그는 그냥 이름을 생략해서도 사용할 수 있다.

```jsx
const rootElement = document.getElementById("root");
const element = (
    <>
      <h1>Hi</h1>
      <h3>Bye</h3>
      <h5>Children</h5>
    </>
);

ReactDom.render(element, rootElement);
```

최종적으로 위와같은 코드가 된다.

## 05. Element 찍어내기

리액트에는 컴포넌트라는 개념이 있다. 함수를 통해 특정한 요소를 생성할 수 있고, 그 함수를 사용함으로써 같은 형식의 요소를 계속 찍어낼 수 있다. 

그 함수는 반드시 영어 대문자로 시작해야하고 `children`의 개수는 제한이 없다.

```jsx
const rootElement = document.getElementById("root");

const Paint = ({ title, description }) => (
  <>
    <h1>{title}</h1>
    <h3>{description}</h3>
  </>
);

const element = (
  <>
    <Paint title="Good" description="good" />
    <Paint title="Bad" description="bad" />
    <Paint title="So so" description="so so" />
  </>
);

ReactDom.render(element, rootElement);
```

## 06. JS와 JSX 섞어쓰기

우리는 아래와 같이 JS 문법과 JSX 문법을 섞어씀으로써 복잡한 일도 해낼 수 있다. 

이렇게 여러 문법을 섞어쓰는 것은 'interpolation'이라고 한다.

```jsx
const rootElement = document.getElementById("root");

function Number({ number, selected }) {
  return selected ? <h1>{number}</h1> : <h3>{number}</h3>;
}

const element = (
  <>
    {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((number) => {
      <Number number={number} selected={number === 3} />;
    })}
  </>
);

ReactDom.render(element, rootElement);
```

## 08. 리액트의 리랜더링 알아보기 1

요소에 변경사항이 생겼을 때, 바닐라 JS와 React는 처리하는 방법이 다르다.

바닐라 JS는 Element를 다시 그리고, 리액트는 변경된 부분만 다시 그린다. 아래는 두가지 예시 코드이다.

**바닐라 JS**

```js
const rootElement = document.getElementById("root");
function random() {
  const number = Math.floor(Math.random() * (10 - 1) + 1);
  const element = `
  <button>${number}</button>
  `;

  rootElement.innerHTML = element;
}
setInterval(random, 1000);
```

**리액트**

```jsx
const rootElement = document.getElementById("root");
function random() {
  const number = Math.floor(Math.random() * (10 - 1) + 1);
  const element = <button>{number}</button>;
  ReactDOM.render(element, rootElement);
}
setInterval(random, 1000);
```

## 09. 리액트의 리랜더링 알아보기 2

위에서 봤듯이 리액트는 변경된 부분만 다시 랜더링한다. 어떤 원리로 이루어지는지 알아보자.

리액트의 엘리먼트는 불변객체(immutable)이다. 즉 변하지 않는 객체인다 우리는 그저 `ReactDOM.reader()` 로 전달할 뿐 변경 판단 및 반영은 리액트가 알아서 한다.

그럼 리액트는 어떤 일을 할까? 일단 엘리먼트 타입이 바뀐다면 이전 엘리먼트는 버리고 새로 그린다. 하지만 엘리먼트 타입이 같다면? 'props'를 비교해서 변경사항을 반영한다. 이를 'Reconciliation' 이라고도 한다. 그리고 비교시에 'Virtual Dom'을 활용한다.

## 10. 이벤트 핸들러 써보기 1

자바스크립트와 똑같다. 다른 점은, 자바스크립트는 이벤트명을 소문자로 작성하지만 리액트는 **카멜 케이스**로 작성한다.

```jsx
const rootElement = document.getElementById("root");

const element = (
  <button
    onClick={() => alert("pressed")}
    onMouseOut={() => alert("bye")}
  >
    pressed
  </button>
);
ReactDOM.render(element, rootElement);
```

## 11. 이벤트 핸들러 써보기 2

상태 객체를 이용하면 더 복잡한 일들을 처리할 수 있다. 상태 객체를 전역으로 선언하고 상태에 따라 속성 값을 변경 시켜주며, 상태에 따른 결과를 출력할 수 있다.

```jsx
const rootElement = document.getElementById("root");

const state = { keyword: "", typing: false, result: "" };

const App = () => {
  function handleChange(event) {
    setState({ typing: true, keyword: event.target.value });
  }

  function handleClick() {
    setState({
      typing: false,
      result: `We find results of ${state.keyword}`,
    });
  }

  return (
    <>
      <input onChange={handleChange} />
      <button onClick={handleClick}> search</button>
      <p>{state.typing ? `Looking for ${state.keyword}...` : state.result}</p>
    </>
  );
};

function setState(newState) {
  Object.assign(state, newState);
  render();
}

function render() {
  ReactDOM.render(<App />, rootElement);
}

render();

```
