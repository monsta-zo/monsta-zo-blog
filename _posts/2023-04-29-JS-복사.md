---
layout: single
title: "[JavaScript] 얕은 복사, 깊은 복사"
categories: JavaScript
tag: [JavaScript]
toc: true
toc_sticky: true
author_profile: false
sidebar:
  nav: "docs"
header:
  teaser: /assets/images/javascript.png
---

> 배열을 복사해서 새로운 배열을 만든 후, 새로운 배열을 수정했는데 기존 배열도 수정되는 경우가 많다. 그 이유는 배열이 '얕은 복사'가 되었기 때문이다. 얕은 복사와 깊은 복사에 대해서 알아보자.

<br>

# 얕은 복사 VS 깊은 복사

우리는 `=(대입 연산자)`를 이용해서 변수를 복사하면 해당 변수에 저장된 값을 복사한다. 하지만 여기서 주의해야할 점이 있다.

자바스크립트의 데이터 타입은 크게 두가지로 나뉜다. 바로 **원시 타입**과 **참조 타입**이다.

> 원시 타입 - 변수에 실제 데이터의 값을 저장
>
> 참조 타입 - 변수에 데이터가 모여있는 메모리의 주소를 저장

즉, 원시 타입은 변수에 실제 데이터의 값을 저장하고, 참조 타입은 변수에 실제 데이터들이 모여있는 메모리의 주소를 저장하기 때문에 `=`를 통해 원시 타입을 복사할 데이터의 값만 잘 복사되지만, 참조 타입을 복사하면 '**데이터들이 모여있는 메모리의 주소**'를 복사하기 때문에 결국 원본과 복사본은 같은 메모리 주소를 가리키게 된다.

이로 인해, 해당 주소로 가서 데이터의 값을 변경시키면, 원본과 복사본 모두 데이터가 수정된다. 이를 **얕은 복사** 라고 한다.

반대로, 주소를 복사하는 것이 아닌 직접 그 주소로 찾아가서 해당 데이터의 값들을 일일히 복사한다면 이는 **깊은 복사**가 되는 것이다.

# 얕은 복사 (shallow copy)

데이터의 값이 직접 복사된 것이 아닌, 데이터를 가리키는 주소가 복사된 것. 일반적으로 참조 타입을 `= (대입 연산자)`로 복사하면 얕은 복사가 된다.

원시 타입은 모두 깊은 복사가 되기 때문에 괜찮지만, 배열이나 객체 같은 참조 타입은 일반적으로 얕은 보사가 된다. 따라서 얕은 복사가 된 배열의 요소를 변경하면 다른 모든 복사본이나 원본에서도 변경되므로 주의해야하고, 의도적으로 깊은 복사를 해줄 필요가 있다.

## 1. 얕은 복사의 예시

새로운 배열 `arr2`에 `arr1`을 얕은 복사한 경우다. `arr1`의 4번째 요소를 0으로 변경했는데 `arr2`의 4번째 요소도 똑같이 변경된다.

```js
let arr1 = [1, 2, 3, 4];
let arr2 = arr1;

arr1[3] = 0;

console.log(arr1); // [1, 2, 3, 0]
console.log(arr2); // [1, 2, 3, 0]
```

# 깊은 복사 (deep copy)

데이터의 값이 직접 복사된 것. 일반적으로 원시 타입을 `= (대입 연산자)`로 복사하면 깊은 복사가 된다.

## 2. 깊은 복사 하는법

원시 타입은 기본적으로 **깊은 복사**가 된다고 했다. 따라서 우리는 배열을 깊은 복사하고 싶다면 '**배열의 요소들을 직접 하나하나 원시 타입으로 여겨 복사**'해야 한다. 이때, 우리는 ...(spread syntax)를 사용할 수 있다.

전개 구문은 배열이나 객체를 분해하여 각각의 요소로 만들어 준다. 즉, 전개 구문을 통해 복사를 하게 되면 배열을 복사하는 것이 아닌, 각각의 요소들을 복사하는 것이다. 아래의 예시를 보자

```js
let arr1 = [1, 2, 3, 4];
let arr2 = [...arr1];

arr1[3] = 0;

console.log(arr1); // [1, 2, 3, 0]
console.log(arr2); // [1, 2, 3, 4]
```

아까의 얕은 복사와 `[...arr1]` 부분만 다를 뿐인데 깊은 복사가 되었다. 그 이유는 전개 구문을 통해 배열의 요소 각각을 다 깊은 복사한 것이기 때문이다.

중요한 것은 단순히 전개 구문을 사용했다는 것이 아닌, <u>전개 구문을 통해</u> 각 요소들을 하나씩 끄집어내서 일일히 깊은 복사를 했다는 그 원리가 중요한 것이다.

이 원리를 잘 이해해야지 어떠한 경우에서도 깊은 복사를 할 수 있다. 예를 들어 2차원 배열과 같은 경우가 있다. 아래의 예시를 보자

```js
let arr1 = [
  [1, 2, 3],
  [4, 5, 6],
];
let arr2 = [...arr1];

arr1[0][2] = 0;

console.log(arr1); // [[1,2,0],[4,5,6]]
console.log(arr2); // [[1,2,0],[4,5,6]]
```

분명 전개 구문을 사용했는데 왜 이번엔 얕은 복사가 되었을까? 아까도 말했듯이 전개 구문 그 자체가 중요한 것이 아닌, 그 원리를 이해해야 한다.

우리는 전개 구문을 통해 `arr1`을 전개 했다. 따라서 `arr1`의 각 요소들이 `= (대입 연산자)` 를 통해 복사 되었다. 근데 `arr1`의 각 요소들이 누구인가? 바로 `[1,2,3]`과 `[4,5,6]`이다. 즉, 배열인 것이다. 위에서 말했듯 배열을 `= (대입 연산자)`를 통해 복사하면 **얕은 복사**가 된다. 우리는 분명 전개 구문을 사용했지만, 각 요소들이 배열이기 때문에 결국 각 요소들이 **얕은 복사**가 된 것이다. 따라서 우리는 이런 2차원 배열을 깊은 복사하기 위해서는 각 요소들까지도 전개하여 일일히 **깊은 복사**를 해줘야 한다.

```js
let arr1 = [
  [1, 2, 3],
  [4, 5, 6],
];
let arr2 = [];
arr1.forEach((ele, idx) => {
  arr2[idx] = [...ele];
});

arr1[0][2] = 0;

console.log(arr1);
console.log(arr2);
```

`arr2`의 각 요소를 다시 한번 일일히 전개해서 복사하였고 따라서, 깊은 복사가 되었다.
